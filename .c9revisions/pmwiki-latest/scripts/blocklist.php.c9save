{"ts":1371754559198,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"<?php if (!defined('PmWiki')) exit();\n/*  Copyright 2006-2013 Patrick R. Michaud (pmichaud@pobox.com)\n    This file is part of PmWiki; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published\n    by the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.  See pmwiki.php for full details.\n\n    This script adds blocklisting capabilities to PmWiki, and can\n    be enabled by simply setting the following in local/config.php:\n\n        $EnableBlocklist = 1;\n\n    With $EnableBlocklist set to 1, this module will search through\n    the SiteAdmin.Blocklist page, as well as any other pages given by\n    the $Blocklist pages variable, looking for lines of the\n    form \"block:some phrase\" or \"block:/regex/\", with \"some phrase\" \n    and \"/regex/\" indicating things to be excluded from any \n    posting to the site.  \n\n    In addition, if a page contains IP addresses of the form\n    \"a.b.c.d\" or \"a.b.c.*\", then any posts coming from hosts\n    matching the address will be blocked.\n\n    There is also an \"unblock:...\" form, which removes an entry\n    from the blocklist.  This is useful for removing specific\n    block items in wikifarms and with automatically downloaded\n    blocklists (below).\n\n    The script also has the capability of automatically downloading\n    blocklists from other sources, such as chongqed.org and\n    and the MoinMaster blocklist.  These are configured using\n    the $BlocklistDownload array.  An $EnableBlocklist value\n    of at least 10 configures PmWiki to automatically download\n    these external blocklists and refresh them daily.\n\n    More information about blocklists is available in the\n    PmWiki.Blocklist page.\n*/\n\n\n##   Some recipes do page updates outside of the built-in posting\n##   cycle, so $EnableBlocklistImmediate is used to determine if\n##   we need to catch these.  Currently this defaults to enabled,\n##   but at some point we may change the default to disabled.\nif (IsEnabled($EnableBlocklistImmediate, 1)) {\n  SDVA($BlocklistActions, array('comment' => 1));\n  if (isset($_POST['text']) && @$BlocklistActions[$action]) {\n    Blocklist($pagename, $_POST['text']);\n    if (!$EnablePost) {\n      unset($_POST['post']);\n      unset($_POST['postattr']);\n      unset($_POST['postedit']);\n    }\n  }\n}\n\n\n##   If $EnableBlocklist is set to 10 or higher, then arrange to \n##   periodically download the \"chongqed\" and \"moinmaster\" blacklists.\nif ($EnableBlocklist >= 10) {\n#  SDVA($BlocklistDownload['SiteAdmin.Blocklist-Chongqed'], array(\n#    'url' => 'http://blacklist.chongqed.org/',\n#    'format' => 'regex'));\n  SDVA($BlocklistDownload['SiteAdmin.Blocklist-MoinMaster'], array(\n    'url' => 'http://moinmo.in/BadContent?action=raw',\n    'format' => 'regex'));\n}\n\n\n##   CheckBlocklist is inserted into $EditFunctions, to automatically\n##   check for blocks on anything being posted through the normal\n##   \"update a page cycle\"\narray_unshift($EditFunctions, 'CheckBlocklist');\nfunction CheckBlocklist($pagename, &$page, &$new) { \n  StopWatch(\"CheckBlocklist: begin $pagename\");\n  $ptext = implode('', @$_POST);\n  if (@$ptext) Blocklist($pagename, $ptext); \n  StopWatch(\"CheckBlocklist: end $pagename\");\n}\n\n\n##   Blocklist is the function that does all of the work of\n##   checking for reasons to block a posting.  It reads\n##   the available blocklist pages ($BlocklistPages) and\n##   builds an array of strings and regular expressiongs to\n##   be checked against the page; if any are found, then\n##   posting is blocked (via $EnablePost=0).  The function\n##   also checks the REMOTE_ADDR against any blocked IP addresses.\nfunction Blocklist($pagename, $text) {\n  global $BlocklistPages, $BlockedMessagesFmt, $BlocklistDownload,\n    $BlocklistDownloadRefresh, $Now, $EnablePost, $WhyBlockedFmt,\n    $MessagesFmt, $BlocklistMessageFmt, $EnableWhyBlocked, $IsBlocked;\n\n  StopWatch(\"Blocklist: begin $pagename\");\n\n  $BlocklistDownload = (array)@$BlocklistDownload;\n  SDV($BlocklistPages, \n    array_merge(array('$SiteAdminGroup.Blocklist', \n                      '$SiteAdminGroup.Blocklist-Farm'),\n                array_keys($BlocklistDownload)));\n  SDV($BlocklistMessageFmt, \"<h3 class='wikimessage'>$[This post has been blocked by the administrator]</h3>\");\n  SDVA($BlockedMessagesFmt, array(\n    'ip' => '$[Address blocked from posting]: ',\n    'text' => '$[Text blocked from posting]: '));\n  SDV($BlocklistDownloadRefresh, 86400);\n\n  ##  Loop over all blocklist pages\n  foreach((array)$BlocklistPages as $b) {\n\n    ##  load the current blocklist page\n    $pn = FmtPageName($b, $pagename);\n    $page = ReadPage($pn, READPAGE_CURRENT);\n    if (!$page) continue;\n\n    ##  if the page being checked is a blocklist page, stop blocking\n    if ($pagename == $pn) return;\n\n    ##  If the blocklist page is managed by automatic download,\n    ##  schedule any new downloads here\n    if (@$BlocklistDownload[$pn]) {\n      $bd = &$BlocklistDownload[$pn];\n      SDVA($bd, array(\n        'refresh' => $BlocklistDownloadRefresh,\n        'url' => \"http://www.pmwiki.org/blocklists/$pn\" ));\n      if (!@$page['text'] || $page['time'] < $Now - $bd['refresh'])\n        register_shutdown_function('BlocklistDownload', $pn, getcwd());\n    }\n\n    ##  If the blocklist is simply a list of regexes to be matched, load \n    ##  them into $terms['block'] and continue to the next blocklist page.\n    ##  Some regexes from remote sites aren't well-formed, so we have\n    ##  to escape any slashes that aren't already escaped.\n    if (strpos(@$page['text'], 'blocklist-format: regex') !==false) {\n      if (preg_match_all('/^([^\\\\s#].+)/m', $page['text'], $match)) \n        foreach($match[0] as $m) {\n          $m = preg_replace('#(?<!\\\\\\\\)/#', '\\\\/', trim($m));\n          $terms['block'][] = \"/$m/\";\n        }\n      continue;\n    }\n\n    ##  Treat the page as a pmwiki-format blocklist page, with\n    ##  IP addresses and \"block:\"-style declarations.  First, see\n    ##  if we need to block the author based on a.b.c.d or a.b.c.*\n    ##  IP addresses.\n    $ip = preg_quote($_SERVER['REMOTE_ADDR']);\n    $ip = preg_replace('/\\\\d+$/', '($0\\\\b|\\\\*)', $ip);\n    if (preg_match(\"/\\\\b$ip/\", @$page['text'], $match)) {\n      $EnablePost = 0;\n      $IsBlocked = 1;\n      $WhyBlockedFmt[] = $BlockedMessagesFmt['ip'] . $match[0];\n    }\n\n    ##  Now we'll load any \"block:\" or \"unblock:\" specifications\n    ##  from the page text.\n    if (preg_match_all('/(un)?(?:block|regex):(.*)/', @$page['text'], \n                       $match, PREG_SET_ORDER)) \n      foreach($match as $m) $terms[$m[1].'block'][] = trim($m[2]);\n  }\n\n  ##  okay, we've loaded all of the terms, now subtract any 'unblock'\n  ##  terms from the block set.\n  StopWatch(\"Blocklist: diff unblock\");\n  $blockterms = array_diff((array)@$terms['block'], (array)@$terms['unblock']);\n\n  ##  go through each of the remaining blockterms and see if it matches the\n  ##  text -- if so, disable posting and add a message to $WhyBlockedFmt.\n  StopWatch('Blocklist: blockterms (count='.count($blockterms).')');\n  $itext = strtolower($text);\n  foreach($blockterms as $b) {\n    if ($b{0} == '/') {\n      if (!preg_match($b, $text)) continue;\n    } else if (strpos($itext, strtolower($b)) === false) continue;\n    $EnablePost = 0;\n    $IsBlocked = 1;\n    $WhyBlockedFmt[] = $BlockedMessagesFmt['text'] . $b;\n  }\n  StopWatch('Blocklist: blockterms done');\n\n  ##  If we came across any reasons to block, let's provide a message\n  ##  to the author that it was blocked.  If $EnableWhyBlocked is set,\n  ##  we'll even tell the author why.  :-)\n  if (@$WhyBlockedFmt) {\n    $MessagesFmt[] = $BlocklistMessageFmt;\n    if (IsEnabled($EnableWhyBlocked, 0)) \n      foreach((array)$WhyBlockedFmt as $why) \n        $MessagesFmt[] = \"<pre class='blocklistmessage'>$why</pre>\\n\";\n  }\n  StopWatch(\"Blocklist: end $pagename\");\n}\n\n\n##   BlocklistDownload() handles retrieving blocklists from\n##   external sources into PmWiki pages.  If it's able to\n##   download an updated list, it uses that; otherwise it leaves\n##   any existing list alone.\nfunction BlocklistDownload($pagename, $dir = '') {\n  global $BlocklistDownloadFmt, $BlocklistDownload, $FmtV;\n\n  if ($dir) { flush(); chdir($dir); }\n  SDV($BlocklistDownloadFmt, \"\n  [@\n## blocklist-note:   NOTE: This page is automatically generated by blocklist.php\n## blocklist-note:   NOTE: Any edits to this page may be lost!\n## blocklist-url:    \\$BlocklistDownloadUrl\n## blocklist-when:   \\$CurrentTimeISO\n#  blocklist-format: \\$BlocklistFormat\n\\$BlocklistData\n  @]\n\");\n\n  ##  get the existing blocklist page\n  $bd = &$BlocklistDownload[$pagename];\n  $page = ReadPage($pagename, READPAGE_CURRENT);\n\n  ##  try to retrieve the remote data\n  $blocklistdata = @file($bd['url']);\n\n  ##  if we didn't get it, and we don't already have text, save a\n  ##  note in the page so we know what happened\n  if (!$blocklistdata && !@$page['text']) {\n    $auf = ini_get('allow_url_fopen');\n    $blocklistdata = \"#### Unable to download blocklist (allow_url_fopen=$auf)\";\n  }\n\n  ##  if we have some new text to save, let's format it and save it\n  if ($blocklistdata) {\n    $blocklistdata = implode('', (array)$blocklistdata);\n    $blocklistdata = preg_replace('/^##blocklist.*/m', '', $blocklistdata);\n    $FmtV['$BlocklistData'] = $blocklistdata;\n    $FmtV['$BlocklistDownloadUrl'] = $bd['url'];\n    $FmtV['$BlocklistFormat'] = $bd['format'];\n    $page['text'] = FmtPageName($BlocklistDownloadFmt, $pagename);\n    SDV($page['passwdread'], '@lock');\n  }\n\n  ##  save our updated(?) blocklist page\n  WritePage($pagename, $page);\n}\n"]],"start1":0,"start2":0,"length1":0,"length2":9602}]],"length":9602}
